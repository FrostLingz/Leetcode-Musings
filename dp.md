## DP
[动态规划](https://labuladong.github.io/algo/1/7/)

求解动态规划的核心问题是**穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。  

虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」，才能正确地穷举。
而且，需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，
所以需要使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**

力扣第 322 题「[零钱兑换](https://leetcode.cn/problems/coin-change/)」

如何找到动态规划的状态转移关系：

>1、明确 dp 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。  
>2、根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。
>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；  
>或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。


**动规五部曲** 以斐波那契数为例  

1.确定dp数组以及下标的含义

>dp[i]的定义为：第i个数的斐波那契数值是dp[i]

2.确定递推公式

>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];

3.dp数组如何初始化

>dp[0] = 0;
>dp[1] = 1;

4.确定遍历顺序
>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

5.举例推导dp数组
>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，推导一下，当N为10的时候，dp数组应该是如下的数列：
>0 1 1 2 3 5 8 13 21 34 55
>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。
